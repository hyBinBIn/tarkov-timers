<!doctype html>
<html lang="ko">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>EFT 상인 리셋 타이머</title>
<style>
  :root { color-scheme: light dark; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 14px; }
  h2 { margin: 0 0 12px; font-size: 18px; }
  .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(230px,1fr)); gap: 12px; }
  .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; }
  .name { font-weight: 700; margin-bottom: 4px; }
  .time { font-size: 1.1rem; }
  .hint { color: #666; font-size: 12px; margin-top: 6px; }
  .error { color: #c00; white-space: pre-wrap; }
  .bar  { height: 6px; background: #eee; border-radius: 99px; overflow: hidden; margin-top: 6px; }
  .fill { height: 100%; width: 0%; background: #6aa9ff; transition: width 0.2s linear; }
  .footer { color:#666; font-size:12px; margin-top:10px }
</style>

<h2>타르코프 상인 리셋 타이머</h2>
<div id="app">불러오는 중…</div>
<div class="footer">Data: eft-ammo (<code>/api/resetTimers</code>) · Rendered client-side</div>

<script>
// ====== 설정 ======
const PROXY_BASE = "/api/eft-proxy?url="; // 같은 Vercel 프로젝트의 서버리스 프록시 (상대 경로)
const DEFAULT_SOURCE = "https://www.eft-ammo.com/api/resetTimers"; // 네가 찾은 실제 URL
const SLOT_MS_FALLBACK = 2 * 60 * 60 * 1000; // 백업(2시간)

// ====== 유틸 ======
const qs = new URLSearchParams(location.search);
const RAW_TARGET = qs.get("url") || DEFAULT_SOURCE;       // 필요시 ?url=로 소스 바꿔 테스트 가능
const ENDPOINT = PROXY_BASE + encodeURIComponent(RAW_TARGET);

function h(tag, attrs={}, ...kids) {
  const el = document.createElement(tag);
  for (const [k,v] of Object.entries(attrs)) (k === "class" ? (el.className = v) : el.setAttribute(k,v));
  kids.flat().forEach(k => el.append(k?.nodeType ? k : String(k)));
  return el;
}
function fmtRemain(ms) {
  if (ms < 0) ms = 0;
  const s = Math.floor(ms / 1000);
  const hh = String(Math.floor(s / 3600)).padStart(2,"0");
  const mm = String(Math.floor((s % 3600) / 60)).padStart(2,"0");
  const ss = String(s % 60).padStart(2,"0");
  return `${hh}:${mm}:${ss}`;
}
function toSeoul(ts) {
  const d = new Date(ts);
  return new Intl.DateTimeFormat("ko-KR", {
    timeZone: "Asia/Seoul",
    year: "numeric", month: "2-digit", day: "2-digit",
    hour: "2-digit", minute: "2-digit", second: "2-digit"
  }).format(d);
}
function nextSlotTs(now = Date.now()) { return Math.ceil(now / SLOT_MS_FALLBACK) * SLOT_MS_FALLBACK; }

// 응답 구조에 맞춰 느슨하게 매핑
function parseRow(x) {
  const name = x.name || x.trader || x.title || x.normalizedName || x.id || "";

  let nextTs = null;
  const abs = x.nextResetUtc ?? x.nextReset ?? x.resetTime ?? x.next ?? x.next_reset ?? x.resetAt ?? x.restockAt ?? x.restock ?? null;
  if (abs != null) {
    if (typeof abs === "number") nextTs = abs > 1e12 ? abs : abs * 1000;
    else {
      const t = Date.parse(abs);
      if (!Number.isNaN(t)) nextTs = t;
    }
  }
  const secondsLeft = x.secondsLeft ?? x.remains ?? x.remaining ?? x.seconds ?? x.countdown ?? null;
  const totalSeconds = x.totalSeconds ?? x.periodSeconds ?? null;

  return { name, nextTs, secondsLeft, totalSeconds };
}

async function main() {
  const app = document.getElementById("app");
  try {
    const r = await fetch(ENDPOINT);
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    const ct = r.headers.get("content-type") || "";
    const raw = ct.includes("application/json") ? await r.json() : JSON.parse(await r.text());

    const arr = Array.isArray(raw) ? raw : (raw.traders || raw.data || raw.result || raw.items || raw.rows || []);
    if (!Array.isArray(arr) || arr.length === 0) {
      app.innerHTML = '<div class="error">타이머 데이터가 비어있거나 구조가 다릅니다. 응답 JSON을 확인하세요.</div>';
      console.debug("raw response:", raw);
      return;
    }

    const list = arr.map(parseRow).filter(r => r.name);
    if (list.length === 0) {
      app.innerHTML = '<div class="error">상인 이름을 찾지 못했습니다. 필드 매핑을 조정하세요.</div>';
      console.debug("raw response:", raw);
      return;
    }

    const grid = h("div", { class: "grid" }, list.map(row => {
      const timer = h("div", { class: "time" }, "—");
      const abs = h("div", { class: "hint" }, "");
      const bar = h("div", { class: "bar" }, h("div", { class: "fill" }));
      const card = h("div", { class: "card" },
        h("div", { class: "name" }, row.name),
        timer, abs, bar
      );

      const startedAt = Date.now();
      const totalMs =
        row.totalSeconds != null ? row.totalSeconds * 1000 :
        row.secondsLeft  != null ? row.secondsLeft  * 1000 :
        row.nextTs ? (row.nextTs - startedAt) :
        SLOT_MS_FALLBACK;

      function tick() {
        const now = Date.now();
        let remainMs = null;

        if (row.secondsLeft != null) remainMs = row.secondsLeft * 1000 - (now - startedAt);
        else if (row.nextTs)       remainMs = row.nextTs - now;
        else                       remainMs = nextSlotTs(now) - now;

        timer.textContent = `다음 리셋까지 ${fmtRemain(remainMs)}`;
        if (row.nextTs) abs.textContent = `(한국 시간: ${toSeoul(row.nextTs)})`;

        const used = Math.max(0, totalMs - Math.max(0, remainMs));
        const pct = Math.max(0, Math.min(100, (used / (totalMs || SLOT_MS_FALLBACK)) * 100));
        bar.querySelector(".fill").style.width = pct.toFixed(2) + "%";
      }

      tick();
      setInterval(tick, 1000);
      return card;
    }));

    app.replaceChildren(grid);
  } catch (e) {
    app.innerHTML = `<div class="error">불러오기 실패: ${String(e)}</div>`;
  }
}
main();
</script>
</html>
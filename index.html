<!doctype html>
<html lang="ko">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>EFT 상인 리셋 타이머</title>
<style>
  :root { color-scheme: light dark; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
  h2 { margin: 0 0 14px; font-size: 18px; }
  .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px,1fr)); gap: 12px; }
  .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; display: flex; flex-direction: column; align-items: flex-start; }
  .row  { display: flex; gap: 10px; align-items: center; width: 100%; }
  .name { font-weight: 800; font-size: 16px; }
  .time { font-size: 1.15rem; margin-top: 8px; }
  .hint { color: #666; font-size: 12px; margin-top: 6px; }
  .img  { width: 56px; height: 56px; border-radius: 10px; object-fit: cover; background: #eee; flex: 0 0 auto; }
  .error { color: #c00; white-space: pre-wrap; }
  .footer { color:#666; font-size:12px; margin-top:12px }
</style>

<h2>타르코프 상인 리셋 타이머</h2>
<div id="app">불러오는 중…</div>
<div class="footer">Data: eft-ammo (<code>/api/resetTimers</code>) · Rendered client-side</div>

<script>
/* ================= 설정 ================= */
const PROXY_BASE = "/api/eft-proxy?url="; // 같은 Vercel 프로젝트의 서버리스 프록시
const DEFAULT_SOURCE = "https://www.eft-ammo.com/api/resetTimers";

/* 제외할 상인 (소문자 키) */
const EXCLUDE = new Set(["lightkeeper", "Btr driver", "ref"]);

/* 화면 표시에 쓸 순서(8명만) */
const TRADER_ORDER = ["prapor","therapist","fence","skier","peacekeeper","mechanic","ragman","jaeger"];

/* ================= 유틸 ================= */
const qs = new URLSearchParams(location.search);
const RAW_TARGET = qs.get("url") || DEFAULT_SOURCE;
const ENDPOINT = PROXY_BASE + encodeURIComponent(RAW_TARGET);

function h(tag, attrs={}, ...kids) {
  const el=document.createElement(tag);
  for (const [k,v] of Object.entries(attrs)) (k==="class"?el.className=v:el.setAttribute(k,v));
  kids.flat().forEach(k=>el.append(k?.nodeType?k:String(k)));
  return el;
}
const NAME_FIX = s => s.replace(/^\w/,c=>c.toUpperCase());
function fmtRemain(ms){ if(ms<0)ms=0; const s=Math.floor(ms/1000);
  const hh=String(Math.floor(s/3600)).padStart(2,"0");
  const mm=String(Math.floor((s%3600)/60)).padStart(2,"0");
  const ss=String(s%60).padStart(2,"0"); return `${hh}:${mm}:${ss}`;}
function toSeoul(ts){ const d=new Date(ts);
  return new Intl.DateTimeFormat("ko-KR",{timeZone:"Asia/Seoul",year:"numeric",month:"2-digit",day:"2-digit",hour:"2-digit",minute:"2-digit",second:"2-digit"}).format(d);}

/* resetTimers → [{name, resetTimestamp}] */
function parseRow(x){
  const rawName = String(x.name||"").toLowerCase();
  const name = NAME_FIX(rawName);
  const nextTs = Date.parse(x.resetTimestamp);
  return { key: rawName, name, nextTs };
}

/* 정렬 헬퍼 */
function sortByOrder(list){ 
  const idx=new Map(TRADER_ORDER.map((n,i)=>[n,i]));
  return list.sort((a,b)=>(idx.get(a.key)??999)-(idx.get(b.key)??999)); 
}

/* 타이머 JSON */
async function fetchTimers(){
  const r=await fetch(ENDPOINT);
  if(!r.ok) throw new Error(`resetTimers HTTP ${r.status}`);
  const raw=await r.json();
  const arr=raw?.data?.traderResetTimes ?? [];
  return arr.map(parseRow)
            .filter(r=>!isNaN(r.nextTs))
            .filter(r=>!EXCLUDE.has(r.key)); // ★ 여기서 제외
}

/* 이미지: tarkov.dev GraphQL에서 가져오기 */
async function fetchTraderImages(){
  const gqlURL = "https://api.tarkov.dev/graphql";
  const body = JSON.stringify({ query: `query { traders { normalizedName imageLink name } }` });
  const r = await fetch(PROXY_BASE + encodeURIComponent(gqlURL), {
    method: "POST",
    headers: { "content-type": "application/json" },
    body
  });
  if(!r.ok) throw new Error(`graphql HTTP ${r.status}`);
  const j = await r.json();
  const map = new Map();
  for (const t of j?.data?.traders || []) {
    const key = String(t.normalizedName||t.name||"").toLowerCase();
    if (!EXCLUDE.has(key)) { // ★ 이미지도 제외 셋은 스킵
      if (key) map.set(key, t.imageLink || "");
    }
  }
  return map;
}

/* ================= 메인 ================= */
async function main(){
  const app=document.getElementById("app");
  try{
    // 1) 타이머(제외 적용됨)
    let list = await fetchTimers();

    // 2) 이미지 맵
    const imgMap = await fetchTraderImages();

    // 3) 순서 정렬
    list = sortByOrder(list);

    // 4) 렌더
    const grid = h("div",{class:"grid"}, list.map(row=>{
      const imgSrc = imgMap.get(row.key) || "";
      const headerKids = [];
      if (imgSrc) {
        const img = h("img", {
          class:"img", alt: row.name, src: imgSrc, loading:"lazy",
          referrerpolicy:"no-referrer",
          onerror:"this.style.display='none'"
        });
        headerKids.push(img);
      }
      headerKids.push(h("div",{class:"name"}, row.name));
      const header = h("div",{class:"row"}, ...headerKids);

      const timer=h("div",{class:"time"},"—");
      const abs=h("div",{class:"hint"},"(한국 시간: "+toSeoul(row.nextTs)+")");
      const card=h("div",{class:"card"}, header, timer, abs);

      function tick(){ timer.textContent=`다음 리셋까지 ${fmtRemain(row.nextTs - Date.now())}`; }
      tick(); setInterval(tick,1000);
      return card;
    }));
    app.replaceChildren(grid);
  }catch(e){
    app.innerHTML=`<div class="error">불러오기 실패: ${String(e)}</div>`;
  }
}
main();
</script>
</html>





